# 继承机制

## 继承机制1

### 继承与派生的概念

继承是指在已有类的或称为**基类**的基础上创建新类，这个新类就是**派生类**

**单继承：**由一个基类派生的类

![image-20250826142709360](D:\DESKTOP\技术笔记\C++\picture\单继承.png)



**多继承：**由两个或多个基类派生的类

![image-20250826142800408](D:\DESKTOP\技术笔记\C++\picture\多继承.png)



**类的单继承声明格式如下：**

```c++
class 派生类名 : 继承方式 基类名 
{
	派生类成员声明
};
```



**派生类自动的包含了基类的成员，包括所有的数据和操作，而且它还可以增加自身新的成员**



## 继承机制下访问权限

### 派生类的访问控制

- 公有继承

```c++
class 派生类 : public 基类
{
	//...
};
```

- 保护继承

```c++
class 派生类 : protected 基类
{
	//...
};
```

- 私有继承

```c++
class 派生类 : private 基类
{
	//...
};
```



![image-20250826151737894](D:\DESKTOP\技术笔记\C++\picture\基类成员在派生类中的访问属性.png)



## 继承（无参构造和析构）

在继承机制中，基类的构造函数和析构函数是不能继承的

派生类的构造函数负责对来自基类数据成员和新增加的数据成员进行初始化

所以，在执行派生类的构造函数时，需要调用基类的构造函数，并提供基类构造函数所需的参数



### 派生类构造函数执行顺序

1. 基类的构造函数
2. 对象成员的构造函数（如果有的话），有多个时按声明的顺序
3. 派生类的构造函数



### 派生类析构函数执行顺序

1. 派生类的析构函数
2. 对象成员的析构函数（如果有的话），有多个时与声明的顺序相反
3. 基类的析构函数



##继承（带参构造）

### 分两种情况讨论派生类对象的构造

1. 如基类中定义了默认构造函数，且该默认构造函数能够完成派生类对象中基类成员的构造，则派生类构造函数无需显式调用基类构造函数，直接调用基类的默认构造函数即可
2. 若基类中定义了有参数的构造函数，则必须通过派生类构造函数显式调用基类的构造函数，向带参数的构造函数传递参数，这需要用到“成员初始化列表”



因此，派生类的构造函数定义一般格式如下：

```c++
派生类名(参数列表):基类构造函数(参数列表1),子对象成员1(参数列表)......
{
	派生类构造函数体
}
```



## 继承（多继承）

多继承下派生类的声明格式如下：

```c++
class 派生类名:继承方式1 基类名1,继承方式2 基类名2......
{
	派生类类体;
};
```

继承方式：public，protected和private之一，如果缺省，则是private



## 继承机制（成员名限定）

若多个基类中定义有同名成员，则派生类对这些同名成员的访问可能存在冲突

为避免可能出现的成员访问冲突，需要用**成员名限定的方法**显式指定要访问的成员

```c++
基类::成员名
```



## 继承机制（虚基类）

![image-20250828232414648](D:\DESKTOP\技术笔记\C++\picture\继承机制（虚基类）.png)



**定义虚基类的格式如下：**

```c++
class 派生类名:virtual 继承方式 基类名称 
{
	......
};
```



### 虚基类的初始化

1. 所有从虚基类直接或间接派生的类必须在该类构造函数的成员初始化列表列出对虚基类构造函数的调用，**但是只有实际构造对象的类的构造函数才会引发对虚基类构造函数的调用。**而其他基类在成员初始化列表中对虚基类构造函数的调用都会被忽略，从而保证了派生类对象中虚基类成员只会被初始化一次。
2. 若某类构造函数的成员初始化列表中同时列出对虚基类构造函数和非虚基类构造函数的调用，则会**优先执行虚基类的构造函数**。



## 继承机制（赋值兼容规则）

1. 基类对象可以赋值给基类对象，也可以把派生类对象赋值给基类对象。
2. 基类指针可以指向基类对象，也可以指向派生类对象。
3. 基类引用可以指向基类对象，也可以指向派生类对象。
