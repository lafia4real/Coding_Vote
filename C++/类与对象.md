# 类与对象

## 类的定义

**一般形式为**

```c++
class 类名{
	public:
		<公有数据和函数>
	protected:
		<保护数据和函数>
	private:
		<私有数据和函数>
};
```

###**类成员的访问控制**

- 成员缺省定义为private的，私有成员是被隐藏的数据，只有该类的成员函数或者友元函数才可以访问它。
- 保护成员也不能通过对象访问，但是可以被该类或派生类的成员函数访问。
- 公有成员定义了类的外部接口。



### 成员函数的实现

- 可以放在类体内，也可以放在类体外，但是必须在类体内给出原型说明。
- 放在类体内定义的函数被默认为内联函数，而放在类体外定义的函数是一般函数，如果要定义为内联函数则需要在前面加上关键字inline。

在类体外定义成员函数的**一般形式为**

```c++
<返回类型><类名>::<成员函数>(<参数说明>)
{
	类体
}
```



## 对象

对象是类的实例或实体。

**一般格式为**

```c++
	<类名> <对象名表>;
```

例如，声明类Point的对象：

```c++
Point p1,p2;
Point p[3];
Point *p3;
Point &rp = p1;
```



### 对象成员的访问

1. 圆点访问方式

   对象名 . 成员名 或 （*指向对象的指针）. 成员名

2. 指针访问方式

   对象指针变量名 -> 成员名 或（&对象名） -> 成员名



## 类的界面和实现

为了减少代码的重复，加快编译速度，在大型程序设计中，C++的类结构常常被分为两部分：

一部分是类的界面，

而另一部分则是类的实现。

**即用于分文件管理，示例代码如下**

point.h文件存放类的界面

```c++
class Point{
    private:
        int x,y;
    public:
        void value(int a,int b);
        void show();
};
```

而point.cpp文件存放类的实现

```c++
void Point::value(int a,int b){
    x = a;
    y = b;
}

/*	错误写法，inline内联函数不能放在cpp文件里，
/*	这样其他的cpp文件用不到，
/*	换成普通函数存放即可
inline void Point::show(){
    cout << x << '\n' << y << endl;
    cout << "-----------------------" << endl;
}
*/

void Point::show(){
    cout << x << '\n' << y << endl;
    cout << "-----------------------" << endl;
}
```



## 构造函数

构造函数是一种特殊的成员函数，对象的创建和初始化工作可以由它来完成，其格式如下：

```c++
<类名>::<类名>(<形参表>)
{
	<函数体>
}
```

**特点：**

- 被声明为公有
- 函数名与类名相同
- 可以重载
- 不能指定返回类型
- 不能被显式调用



###默认构造函数

即无参数的构造函数，既可以是自己定义的，也可以是编译系统自动生成的

当没有为一个类定义任何构造函数的情况下，编译系统就会自动生成一个无参数、空函数体的默认构造函数



### 构造函数的作用

对象创建时自动调用，用来初始化

**其格式如下：**

```c++
<类名>::<类名>()
{

}
```



## 成员初始化表

带有成员初始化表的构造函数的一般形式如下：

```c++
类名::构造函数名([])[:()]
{
	//构造函数
}
成员初始化表的一般形式为：
	数据成员名1(初始值1),数据成员名2(初始值2),......
```



## 默认函数的构造函数

直接敲代码



## 析构函数

### 析构函数的作用

对象销毁时自动调用，用来清理资源（比如释放文件、关闭网络、释放内存等）。



###析构函数的特点：

- 只能被声明为公有函数
- 析构函数的名字同类名，与构造函数名的区别在于析构函数名前加~，表明它的共功能与构造函数的功能相反
- 析构函数没有参数，不能重载，一个类中只能定义一个析构函数
- 不能指定返回类型
- 析构函数在释放一个对象时候被自动调用



### 默认析构函数

如果一个类中没有定义析构函数时，系统将自动生成一个默认析构函数，其格式如下：

```c++
<类名>::~<类名>()
{

}
```



### 堆和栈不同对象的处理方式

```c++
Point a;           // 栈上，作用域结束时自动 ~Point()
Point *b = new Point;  // 堆上，必须 delete b; 才会 ~Point()

//如果用 new[] 分配数组，要用 delete[]，否则只会析构第一个对象：
Point *arr = new Point[3];
delete[] arr;  // 调用 3 次析构函数
```



### 现代C++建议

为了避免忘记 `delete`，C++11 起推荐用 **智能指针**：

```c++
#include <memory>

int main() {
    auto p = std::make_unique<Point>(); // 构造
} // 作用域结束，智能指针自动调用 delete，触发析构
```



## 拷贝构造函数

### 定义

拷贝构造函数是一种特殊的构造函数，它的作用是用一个已经存在的对象去初始化另一个对象

**其格式为**

```c++
<类名>::<类名>(const<类名>&<对象名>)
{
	<函数体>
}
```



### 特点

- 拷贝构造函数名字与类相同，不能指定返回类型
- 拷贝构造函数只有一个参数，该参数是该类的对象的引用
- 它不能被显式调用

**在以下三种情况下会被自动调用：**

- 当用类的对象去初始化该类的另一个对象时	

```c++
如：
Coord p2(p1);					//用对象p1初始化对象p2
								//拷贝构造函数被调用（代入法）
Coord p3 = p1;					//用对象p1初始化对象p3
								//拷贝构造函数被调用（赋值法）
```

- 当函数的形参是类的对象，进行形参和实参结合时	

```c++
例如：
funl(Coord p)					//函数的形参是类的对象
{
	p.print();
}
main()
{
	Coord p1(10,20);
	funl(p1);					//当调用函数，进行形参和实参结合时
	return 0;
}
```

- 当函数的返回值是类的对象，函数执行完成返回调用者时

```c++
例如：
Coord fun2()
{
	Coord p1(10,30);
	return p1;					//函数的返回值是对象
}
main()
{
	Coord p2;
	p2 = fun2();				//函数执行完成，返回调用者时
	return 0;
}
```



### 遇到的问题

临时对象被编译器优化掉，在cmd里加入

```
g++ -fno-elide-constructors study_project.cpp Point.cpp
```

后再

```
a.exe
```

即可



## 浅拷贝与深拷贝

如果一个类中没有定义拷贝构造函数，则系统自动生成一个默认的拷贝构造函数

如Point类中，默认的拷贝构造函数为：

```c++
Point(const Point &p)
{
	x = p.x;
	y = p.y;
}
```

所谓**浅拷贝**，就是用默认的拷贝构造函数实现数据成员逐一赋值

而**深拷贝**，则是需要自己写拷贝构造函数，实现额外的内容

