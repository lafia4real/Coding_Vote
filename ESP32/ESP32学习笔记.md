# ESP32学习笔记

## 遇到的问题

###每次重启虚拟机都无法编译

重新执行一遍.profile文件即可

```
source .profile
```

### 虚拟机找不到开发板

Ubuntu64位 22.04 GUI 版本烧录的问题，此时会发现brltty服务会占用端口，解决方法有1 ，直接卸载，2 sys服务中禁止brltty开机启动，3 是配置brltty服务不占用端口，建议直接1 sudo apt remove brltty 一步到位 ， 带界面的系统都可能会遇到这个问题，或者是22.04特有的，总而言之卸载后reboot就可以找到USB设备并烧录了



## 基础工程目录解释

###Helloworld

###main

工程主要源码目录，必须存在

#### main.c

工程入口源码文件，必须存在

#### CMakeLists.txt

用于指示CMake构建系统，对main目录进行构建

###CMakeLists.txt

用于指示CMake构建系统，HelloWorld工程必须构建

###components

自己编写的一些公共代码存放，非必须

###skdconfig

工程组件的配置文件，必须存在

###build

执行编译后，生成的bin和中间文件存放，自动生成



##程序存储结构

在使用完idf.py build编译后，编译器会根据我们的代码区分出指令总线和数据总线，指令总线：可以执行的，比如定义的函数，数据总线：不可执行，只能通过字节操作访问，比如全局变量，**以下存储都可以称之为段**

### DRAM（数据RAM）

非常量静态数据（.data段）和零初始化数据（.bss段，一般是数值为0的全局变量）由链接器放入内如SRAM作为数据存储，也可配置放入外部RAM**（也就是static变量或者初始化为0的全局变量都存放在此）**

### “noninit”RAM

未初始化的全局变量数据，由链接器放入内部SRAM作为数据存储，也可配置放入外部RAM

### IRAM（指令RAM）

ESP-IDF将内部SRAM0(SRAM分为3个存储块SRAM0、SRAM1和SRAM2)的部分区域（SRAM0和SRAM1）分配为指令RAM中断处理程序，一般放入指令RAM中

可以通过使用IRAM_ATTR宏在源代码中指定需要放入IRAM的代码**（中断处理程序存放在此）**

### IROM（代码从flash中运行）

如果一个函数没有被显式地声明放在IRAM或者RTC存储器中，则它会放在flash中**（写代码的函数存放在这里）**

### EROM（数据存储在flash中）

用于存放只读数据**（const）**

### RTC Slow memory（RTC慢速存储器）

RTC_NOINIT_ATTR属性宏可以用来将数据放入RTC Slow memory。放入此类存储器的值从深度睡眠模式中醒来后会保持值不变

### RTC FAST memory（RTC快速存储器）

RTC FAST memory的同一区域既可以作为指令存储器也可以作为数据存储器进行访问。从深度睡眠模式唤醒后必须要运行的代码要放在RTC存储器中



## 启动流程

1. 一级引导程序，固化在ROM中，不可修改，加载二级引导程序至RAM中运行，检查IO0引脚，选择程序模式，当芯片上电检测到IO0引脚是低电平时，就会进入下载模式，否则就会继续执行二级引导程序。
2. 二级引导程序，bootloader程序，从0x8000处读取分区表，处理各种段，加载应用程序。
3. 应用程序，硬件外设和基本C语言运行环境的初始化，freertos初始化，最后执行app_main()函数



## FreeRTOS

###任务创建

![image-20251109214731882](D:\DESKTOP\技术笔记\ESP32\picture\任务创建.png)

###阻塞

![image-20251109215014001](D:\DESKTOP\技术笔记\ESP32\picture\阻塞.png)

####两个函数的区别

vTaskDelay:当程序调用这个函数的时候，立刻会进入阻塞状态，**但不意味着经过这么个周期之后可以立刻得到执行，具体要看系统的调度**

vTaskDelayUntil:可以精确解除阻塞时间



###任务间同步

![image-20251109222455119](D:\DESKTOP\技术笔记\ESP32\picture\任务间同步.png)

####同步与互斥的区别

**同步**：为了RTOS中各任务能够协同一起进行工作，在一些关键的运行节点上互相等待或者传输一些关键的数据，比如有三个任务，下一个任务执行前必须要等待上一个任务完成（也就是阻塞在此），使用同步机制进行高效协同完成工作

**互斥**：不是你用就是只能我用，同样也是三个任务，任务A在执行时带着互斥锁执行，而其他任务一直阻塞，等到A完成释放互斥锁给B任务，B才得以执行



同步其实是实现了互斥的功能，只不过同步意味着更多东西



###队列

![image-20251109223253795](D:\DESKTOP\技术笔记\ESP32\picture\队列.png)



###信号量

![image-20251111214354508](D:\DESKTOP\技术笔记\ESP32\picture\信号量.png)

雨伞等于信号量，使用者等于任务，**只有取得信号量，任务才能继续往下执行或者使用特定的资源**



###互斥锁（也属于一种信号量）

![image-20251111214627215](D:\DESKTOP\技术笔记\ESP32\picture\互斥锁.png)



###事件组

![image-20251111225804284](D:\DESKTOP\技术笔记\ESP32\picture\事件组.png)



###直达任务通知

![image-20251111230530886](D:\DESKTOP\技术笔记\ESP32\picture\直达任务通知.png)



## 原生和ESP-IDF中freertos的区别

![image-20251111232419141](D:\DESKTOP\技术笔记\ESP32\picture\原生和ESPIDF中freertos的区别.png)



## 外设

### LED

**LED_PWM呼吸灯**：
初始化TIM，channel/使能硬件。配置渐变，开启渐变/ 中断回调函数+启动任务(开启事件)，一直回调(关键字IRAM_ATTR)

### WS2812

后面自己看着文档重新写一遍驱动

### DHT11

后面自己看着文档重新写一遍驱动

### ADC获取NTC温度

![image-20251119231029026](D:\DESKTOP\技术笔记\ESP32\picture\ADC概念)

![image-20251119231253360](D:\DESKTOP\技术笔记\ESP32\picture\NTC采样)

![image-20251119231407704](D:\DESKTOP\技术笔记\ESP32\picture\NTC电路)

**注：本次ADC转换实验中的ADC连续转换模式经UP主实验，存在诸多问题，比如精度差以及不同通道之间存在干扰，故使用单次转换模式**

![image-20251119232541745](D:\DESKTOP\技术笔记\ESP32\picture\线性插值.png)

最终还是要重新研究一下UP主的ADC部分代码是怎么写的

### HC-SR04

后面自己看着文档重新写一遍驱动

### SD卡

![image-20251123192110490](D:\DESKTOP\技术笔记\ESP32\picture\SD卡.png)

![image-20251123192305469](D:\DESKTOP\技术笔记\ESP32\picture\SD卡发展历史.png)

**MicroSD卡可以使用1bit数据读写SPI模式，也可以使用4位的SDIO模式，4位传输速度更快**

代码编写思路：


主要流程

• 初始化SD卡：

• 配置挂载点、挂载配置参数（如是否格式化、最大文件数、分配单元大小等）。

• 配置SDMMC主机（默认配置，速度20MHz，使用卡槽1）。

• 配置SDMMC槽（默认IO管脚配置，4位数据，启用内部上拉）。

• 尝试挂载文件系统，若失败则根据错误类型输出相应提示并返回。

• 操作文件：

• 打印SD卡信息。

• 创建文件“hello.txt”，写入数据，然后重命名为“foo.txt”，并读取其内容。

• 创建文件“nihao.txt”，写入数据并读取其内容。

• 卸载SD卡：卸载分区并禁用SDMMC外设。


详细分解

• 初始化SD卡

• 配置挂载点：定义挂载点名称`MOUNT_POINT`为`"/sdcard"`。

• 配置挂载配置参数：

• `format_if_mount_failed`：设置为`true`，表示挂载失败时执行格式化。

• `max_files`：设置为`5`，表示最大可打开文件数。

• `allocation_unit_size`：设置为`16 * 1024`，表示执行格式化时的分配单元大小。

• 配置SDMMC主机：

• 使用`SDMMC_HOST_DEFAULT()`获取默认配置，速度为20MHz，使用卡槽1。

• 配置SDMMC槽：

• 使用`SDMMC_SLOT_CONFIG_DEFAULT()`获取默认IO管脚配置。

• 设置数据宽度为4位。

• 启用内部上拉（仅用于调试/示例目的，实际使用时需确保有10k外部上拉电阻）。

• 挂载文件系统：

• 调用`esp_vfs_fat_sdmmc_mount()`函数，传入挂载点、主机配置、槽配置、挂载配置以及卡指针。

• 若挂载失败，根据返回值判断是挂载失败还是初始化卡失败，并输出相应错误提示。

• 操作文件

• 打印SD卡信息：调用`sdmmc_card_print_info()`函数，将SD卡的信息打印到标准输出。

• 创建、重命名、读取文件“hello.txt”：

• 创建文件“hello.txt”，写入数据`"Hello [卡名]!\n"`。

• 检查文件“foo.txt”是否存在，若存在则删除。

• 将文件“hello.txt”重命名为“foo.txt”。

• 读取文件“foo.txt”的内容并打印。

• 创建、读取文件“nihao.txt”：

• 创建文件“nihao.txt”，写入数据`"Nihao [卡名]!\n"`。

• 读取文件“nihao.txt”的内容并打印。

• 卸载SD卡：调用`esp_vfs_fat_sdcard_unmount()`函数，传入挂载点和卡指针，卸载分区并禁用SDMMC外设。



### UART

为什么在ESP32中可以自由设置引脚？关于GPIO矩阵交换：

![image-20251123195036630](D:\DESKTOP\技术笔记\ESP32\picture\GPIO矩阵交换.png)

图中从右往左：

IO_MUX：GPIO的复用寄存器，和STM32类似可以配置GPIO引脚用于其他特定的外设功能，比如说SDIO的DATA1，SPI的MISO等，而这个寄存器还有一个配置就是选择连接内部的GPIO交换矩阵，这样子引脚信号就到了左边这个GPIO矩阵来了

对于每个外设的功能，都可以通过这个GPIO矩阵连接到指定的GPIO引脚上

**当然ESP32中的交换矩阵也不是完全没有限制的，比如说GPIO34,35,36,39这几个引脚只能是作为输入，如果这几个引脚连接到UART2_TX那么ESP-IDF编译会不通过**

### st7789显示芯片

支持SPI和8080并行接口通信，但由于本实验中的ESP32接口比较紧张，故使用SPI协议进行驱动

后面自己看着文档重新写一遍驱动

### CST816T触摸芯片

支持IIC协议（目前市面上大部分的触摸屏都是IIC协议的）

后面自己看着文档重新写一遍驱动



## LVGL

components文件夹：称为组件，在ESP-IDF中，组件可以认为是模块化的代码集合，一般用于实现特定的功能

**LVGL的移植代码需要自己写，分为以下五个步骤**

1、初始化和注册LVGL显示驱动

​		也就是告诉LVGL一个可用于显示画面的设备，这个设备的长和宽是什么，如何向这个设备写入数据，数据缓冲区域等几个信息

​		malloc函数就是要申请的内存区域大小，一般来说是填一个屏幕的1/4到1/6之间，这里要填的内存区域大小不能超过DMA的传输大小，否则一包写不完

2、初始化和注册LVGL触摸驱动

3、初始化ST7789硬件接口

4、初始化CST816T硬件接口

5、提供一个定时器给LVGL使用

